#!/usr/bin/env python
# coding: utf-8
```
Author: Ksymena Poradzisz
Contact: ksymena.poradzisz@gmail.com
Affiliation: Jagiellonian University
Description: This code provides functions which can transform a tensor into Matrix Product State (MPS). MPS can be left-, right- or mixed-cannonical. All of these version can be generated by functions in this code.
```


import numpy as np
from  numpy.linalg import svd
import matplotlib.pyplot as plt

# generates a random ground state of a classical 1D Ising model with n spins 1/2 as
# a rank n tensor of probability amplitudes psi_{0,1,2,\dots,n-1}
def Is_GS(n):
  x = np.random.rand(2)+1.j*np.random.rand(2)
  x = x/np.sqrt(np.vdot(x,x))
  v = np.zeros(2**n,dtype=np.complex128)
  v[0] = x[0]
  v[2**n-1] = x[1]
  v = np.reshape(v,list(np.repeat(2,n)))
  return v

def random(n):
  x = np.random.rand(2**n)+1.j*np.random.rand(2**n)
  x = x/np.sqrt(np.vdot(x,x))
  x = np.reshape(x,list(np.repeat(2,n)))
  return x


#Left canonical MPS
# performs the first step of a left canonical MPS construction 
def to_left_can_first(psi): #takes as an argument psi_{i_0,i_1,..,i_{n-1}}
    sv = psi.shape # returns dimensions of psi_{i_0,i_1,...,i_{n-1}} indices as a tuple (d_0,d_1,...,d_{n-1})
    n = psi.ndim # returns psi rank (n)
    psi = np.reshape(psi,(sv[0],np.prod(sv[1:]))) #merges i_1,...,i_{n-1} indices returning a matrix M_{ij} of dimensions d_0 times d_1*....*d_{n-1}
    [u,s,vh] = np.linalg.svd(psi,full_matrices=False) #performs svd of the matrix
    D = s.size # size of the new index created by svd
    psir = np.diag(s)@vh #multiplies a matrix of singular values by the right singular vectors
    psir = np.reshape(psir,((D,)+sv[1:])) #splits the second index of a matrix of right singular values  indices of the dimensions i_1,..,i_{n-1} 
    return u,psir #u here is the first MPS tensor, psir is a tensor which needs to be decomposed in the next step
# performs the next step of a left canonical MPS construction 
def to_left_can_next(psi): #takes as an argument psi_{i_0,i_1,..,i_{n-1}}
    sv = psi.shape # returns dimensions of psi_{i_0,i_1,...,i_{n-1}} indices as a tuple (d_0,d_1,...,d_{n-1})
    n = psi.ndim # returns psi rank (n)
    psi = np.reshape(psi,(sv[0]*sv[1],np.prod(sv[2:]))) #merges i_1,...,i_{n-1} indices returning a matrix M_{ij} of dimensions d_0 times d_1*....*d_{n-1}
    [u_temp,s,vh] = np.linalg.svd(psi,full_matrices=False) #performs svd of the matrix
    D = s.size # size of the new index created by svd
    psir = np.diag(s)@vh #multiplies a matrix of singular values by the right singular vectors
    psir = np.reshape(psir,((D,)+sv[2:])) #splits the second index of a matrix of right singular values  indices of the dimensions i_1,..,i_{n-1} 
    u = np.reshape(u_temp, (sv[0],sv[1],D))
    return u,psir #u here is the one of the middle MPS tensor, psir is a tensor which needs to be decomposed in the next step
#LCMPS function transforms tensor state into left-canonical MPS
def LCMPS(psi):
    n = len(np.shape(psi)) #number of needed steps
    psi_temp = psi
    mps = []
    [u1, psi_t] = to_left_can_first(psi_temp)
    mps.append(u1)
    for i in range (n-2):
        [u, psi_t] = to_left_can_next(psi_t)
        mps.append(u)
    mps.append(psi_t)
    return mps

#Right canonical
def to_right_can_first(psi): #takes as an argument psi_{i_0,i_1,..,i_{n-1}}
    sv = psi.shape # returns dimensions of psi_{i_0,i_1,...,i_{n-1}} indices as a tuple (d_0,d_1,...,d_{n-1})
    n = psi.ndim # returns psi rank (n)
    psi = np.reshape(psi, (np.prod(sv[:-1]),sv[-1]))
    [u,s,vh] = np.linalg.svd(psi,full_matrices=False) #performs svd of the matrix
    D = s.size # size of the new index created by svd
    psit = u@np.diag(s)
    psit = np.reshape(psit,((sv[:-1]+(D,))))   
    return psit, vh 
def to_right_can_next(psi): #takes as an argument psi_{i_0,i_1,..,i_{n-1}}
    sv = psi.shape # returns dimensions of psi_{i_0,i_1,...,i_{n-1}} indices as a tuple (d_0,d_1,...,d_{n-1})
    n = psi.ndim # returns psi rank (n)
    psi = np.reshape(psi,(np.prod(sv[:-2]),sv[-1]*sv[-2]))
    [u_temp,s,vh] = np.linalg.svd(psi,full_matrices=False) #performs svd of the matrix
    D = s.size # size of the new index created by svd
    psir = u_temp@np.diag(s)
    psir = np.reshape(psir, (sv[:-2]+(D,)))
    vh = np.reshape(vh,(D,sv[-2],sv[-1]))
    return psir, vh #u here is the 
#RCMPS transforms tensor state into right-canonical MPS
def RCMPS(psi):
    n = len(np.shape(psi)) #number of needed steps
    psi_temp = psi
    mps = []
    [psi_t, v1] = to_right_can_first(psi_temp)
    mps.append(v1)
    for i in range (n-2):
        [psi_t, v1] = to_right_can_next(psi_t)
        mps.insert(0,v1)
    mps.insert(0,psi_t)
    return mps

#mix_can function transforms state into mixed-canonical MPS with a cetral site j
def mix_can(psi, j): #psi -state -> mps, j - which state we want to be the center one
    n = len(np.shape(psi)) #number of needed steps
    mps_l = [] #left side
    mps_r = [] #right side
    if j > psi.ndim or j<0:
        raise ValueError('othogonality center is out of range')
    elif j == 0:
        return RCMPS(psi)
    elif j == n-1:
        return LCMPS(psi)
    else:
        [u_l, psi_l] = to_left_can_first(psi)
        mps_l.append(u_l) #add first one
        for i in range(1,j):
            [u_l, psi_l] = to_left_can_next(psi_l)
            mps_l.append(u_l) 
            #the last psi_l will be orthogonality center
        rest =  n-j
        [psi_r, v_r] = to_right_can_first(psi_l)
        mps_r.append(v_r)
        for i in range(rest-2):
            [psi_r, v_r] = to_right_can_next(psi_r) 
            mps_r.insert(0,v_r)
        mps_r.insert(0,psi_r)
        mps = mps_l + mps_r
        return mps
    
def mix_norm(psi,j): #function for calculating norm of mixed canonical state
    return np.tensordot(psi[j],np.conjugate(psi[j]), axes = ([0,1,2],[0,1,2]))
def mix_check(psi,j): #function returning identity matrices if psi is mixed canonical
    temp = []
    temp.append(np.tensordot(psi[0], np.conjugate(psi[0]),axes = ([0,],[0,])))
    for i in range(1,j):
        temp.append(np.tensordot(psi[i], np.conjugate(psi[i]),axes=([0,1],[0,1])))
    for i in range(j+1,len(psi)-1):
        temp.append(np.tensordot(psi[i], np.conjugate(psi[i]),axes=([0,1],[0,1])))
    temp.append(np.tensordot(psi[len(psi)-1], np.conjugate(psi[len(psi)-1]),axes = ([0,],[0,])))
    return temp

#generating a random state of rank 5 and then transforming it inot mixed-canonical MPS. Then we check it this is really mixed-canonical
y = random(5)
mix = mix_can(y,3)
tmp = mix_check(mix,3)
for i in range(len(tmp)):
    sv = np.shape(tmp[i])
    d = sv[0]
    print("shape of a tensor "+str(i)+" is" +str(sv))
    print("result (if approximatly zero then it is good) = "+str(np.linalg.norm(tmp[i]-np.eye(d)))) 

#exp_val_1 function calculates expectation value of 1-site operator at a given site
def exp_val_1(state, op, site): #psi - state in which we calculate expectation value, op - operator, site - at which site we wan to calculate exp
    psi = mix_can(state, site)
    dim = len(np.shape(state))
    if site ==dim-1:
        temp = np.tensordot(op,psi[site], axes = ([0],[1]))
        c = complex(np.tensordot(np.conjugate(psi[site]),temp,axes = ([0,1],[1,0])))
        #return c.real
    elif site == 0:
        temp = np.tensordot(op,psi[site], axes = ([0],[0]))
        c = complex(np.tensordot(np.conjugate(psi[site]),temp,axes = ([0,1],[0,1])))       
    else:
        temp = np.tensordot(op,psi[site], axes = ([0],[1]))
        c = complex(np.tensordot(np.conjugate(psi[site]),temp,axes = ([0,1,2],[1,0,2])))
    return c.real

#exp_val_12function calculates expectation value of 2-sites operator at a given site and given site +1
def exp_val_2(state, S, site): #
    P = mix_can(state,site)
    dim = len(np.shape(state))
    if site ==dim-2:
        t2 = complex(np.einsum('iaj, jb, abcd, icw, wd',P[site],P[site+1],S,np.conjugate(P[site]),np.conjugate(P[site+1])))
    elif site == 0:
        t2 = complex(np.einsum('aj,jbx ,abcd,cw,wdx',P[site],P[site+1],S,np.conjugate(P[site]),np.conjugate(P[site+1])))
    elif site == dim-1:
        raise ValueError('second site is out of range')
    else:
        t2 = complex(np.einsum('iaj, jcx, acbd, ibk, kdx',P[site],P[site+1],S,np.conjugate(P[site]),np.conjugate(P[site+1])))
    return t2.real
#definition of operator action on two sites

